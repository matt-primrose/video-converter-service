# Example configuration for video converter service
# Copy this file to config.yaml and customize for your deployment
#
# For local development:
# 1. Copy this file: cp config.yaml.example config.yaml
# 2. Update FFmpeg paths to point to local binaries (e.g., "./bin/ffmpeg.exe" on Windows)
# 3. Set appropriate storage type and paths
# 4. Replace placeholder tokens/secrets with actual values
# 5. Test Event Grid integration using examples/eventgrid-local-test.json
#
# For production deployment:
# 1. Set sensitive values via environment variables (Azure EventGrid, webhook URLs, storage credentials)
# 2. Configure appropriate storage backend (Azure Blob, S3, etc.)
# 3. Adjust processing limits based on your infrastructure
# 4. Set log_level to "info" or "warn" for production
# 5. Ensure port 8082 is accessible for Event Grid webhook callbacks
#
# Service Ports:
# - 8080: Main HTTP API server
# - 8081: Health check endpoint  
# - 8082: Event Grid webhook receiver (hardcoded)
#
# Environment Variable Precedence:
# Environment variables override config.yaml values using this mapping:
# - EVENT_SOURCES_AZURE_EVENTGRID_ENDPOINT → event_sources.azure_eventgrid.endpoint
# - EVENT_SOURCES_AZURE_EVENTGRID_KEY → event_sources.azure_eventgrid.key
# - EVENT_SOURCES_WEBSOCKET_ENDPOINT → event_sources.websocket.endpoint
# - EVENT_SOURCES_WEBSOCKET_TOKEN → event_sources.websocket.token
# - STORAGE_TYPE → storage.type
# - PROCESSING_MAX_CONCURRENT_JOBS → processing.max_concurrent_jobs
# See docker-compose.yml for complete environment variable examples

server:
  port: 8080
  host: "0.0.0.0"
  health_check_port: 8081

# Event Sources Configuration
# The service supports event-driven video processing from multiple sources
# Configure the sources you want to enable below
event_sources:
  azure_eventgrid:
    # Azure Event Grid integration for blob creation events
    # Webhook endpoint runs on port 8082 (hardcoded)
    # Example production values:
    endpoint: "https://your-eventgrid.azure.net/api/events"  # Your Event Grid topic endpoint
    key: "your-event-grid-sas-key"                           # SAS key for webhook authentication
    # For local testing, use the values from docker-compose.yml:
    # endpoint: "https://test.eventgrid.azure.net/api/events"
    # key: "test-key"
    
  websocket:
    # WebSocket client for real-time event processing
    # Connects to external WebSocket server with automatic reconnection
    endpoint: "ws://localhost:8080/events"        # WebSocket server endpoint
    token: "your-websocket-token-here"            # Authentication token
    # For local testing, use: token: "test-token"

storage:
  # Storage backend for converted video outputs
  # Note: Input sources (via Event Grid) support multiple types automatically:
  #   - Local files: /app/video_source/* (mounted from ./video_source)
  #   - HTTP/HTTPS URLs: Downloaded temporarily for processing
  #   - Azure Blob URLs: Downloaded via Azure SDK with public/authenticated access
  type: "local"  # Options: "local", "azure_blob", "s3"
  local:
    path: "./video_outputs"                 # Final destination for local storage type
  azure_blob:
    account: "your-storage-account"         # Azure storage account name
    container: "video-outputs"              # Container for processed video outputs
    # Note: Input downloading from Azure Blob (via Event Grid) uses public access
    # For authenticated downloads, set AZURE_STORAGE_CONNECTION_STRING environment variable
  s3:
    bucket: "your-s3-bucket"                # S3 bucket for processed video outputs
    region: "us-east-1"

processing:
  max_concurrent_jobs: 2
  job_timeout_minutes: 60  # Increased for longer video processing - adjust based on your needs
  temp_dir: "./video_temp"
  outputs_dir: "./video_outputs"           # Local filesystem staging area (used by all storage types)
  max_temp_disk_gb: 5

ffmpeg:
  binary_path: "ffmpeg"      # Path to FFmpeg binary (use "./bin/ffmpeg.exe" for Windows local dev)
  probe_path: "ffprobe"      # Path to FFprobe binary (use "./bin/ffprobe.exe" for Windows local dev)
  default_preset: "fast"     # FFmpeg preset: ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow
  hardware_accel: ""         # Hardware acceleration: "", "nvenc", "qsv", "vaapi" (leave empty for software encoding)

observability:
  log_level: "info"          # Log level: debug, info, warn, error (use "debug" for development)
  metrics_port: 9090
  enable_tracing: false
  jaeger_endpoint: ""        # Set to your Jaeger endpoint if tracing is enabled

# Job Templates - Define conversion profiles
# The "default" template creates:
# - HLS adaptive bitrate streaming with 5 quality levels (240p to 4k)
# - Progressive MP4 fallback files (720p and 1080p)
# You can customize profiles, bitrates, and output formats as needed
job_templates:
  default:
    outputs:
      - name: "hls-adaptive"
        package: "hls"
        profiles:
          - name: "240p"
            width: 426
            height: 240
            video_bitrate_kbps: 350
            audio_bitrate_kbps: 64
          - name: "360p" 
            width: 640
            height: 360
            video_bitrate_kbps: 700
            audio_bitrate_kbps: 96
          - name: "720p"
            width: 1280
            height: 720
            video_bitrate_kbps: 2500
            audio_bitrate_kbps: 128
          - name: "1080p"
            width: 1920
            height: 1080
            video_bitrate_kbps: 4000
            audio_bitrate_kbps: 128
          - name: "4k"
            width: 3840
            height: 2160
            video_bitrate_kbps: 8000
            audio_bitrate_kbps: 128
        segment_length_s: 6
        container: "fmp4"
        destination: "vod/{videoId}/hls/"

      - name: "progressive-fallback"
        package: "progressive"
        profile: "720p"
        destination: "vod/{videoId}/progressive/720p.mp4"

      - name: "progressive-hd"
        package: "progressive"
        profile: "1080p" 
        destination: "vod/{videoId}/progressive/1080p.mp4"

    ffmpeg:
      preset: "fast"
      hwaccel: ""              # Leave empty for software encoding, or use "nvenc", "qsv", "vaapi" for hardware
      extra_args: []           # Additional FFmpeg arguments (movflags +faststart is handled automatically)

    notifications:
      webhook_url: "https://your-webhook-endpoint.com/video-complete"  # Replace with your webhook URL
      on_complete: true
      on_failure: true

# ==============================================================================
# TESTING CONFIGURATION
# ==============================================================================
# 
# Quick Test Setup (Event Grid Integration):
# 1. Copy this file: cp config.yaml.example config.yaml
# 2. Start service: docker-compose up -d video-converter
# 3. Place test video in: ./video_source/your-video.mp4
# 4. Edit examples/eventgrid-local-test.json to match your filename
# 5. Send test event:
#    curl -X POST http://localhost:8082/webhook/eventgrid \
#      -H "aeg-sas-key: test-key" \
#      -H "aeg-event-type: Notification" \
#      -H "Content-Type: application/json" \
#      -d @examples/eventgrid-local-test.json
# 6. Check results: ls -la video_outputs/job-*/
#
# Test Event Sources:
# - Local files: Place in ./video_source/ (mounted to /app/video_source in container)
# - HTTP URLs: Use examples/eventgrid-public-blob-test.json
# - Azure Blob: Use examples/eventgrid-test.json (requires real Azure Storage account)
#
# Monitoring:
# - Watch logs: docker logs -f video-converter-service-video-converter-1
# - Check health: curl http://localhost:8081/healthz
# - Verify webhook: curl -I http://localhost:8082/webhook/eventgrid
#
# Expected Processing Flow:
# Event Grid → Source Detection → File Download → Transcoding → Output Storage
# Look for log messages: "Job queued" → "sourceType" → "Starting transcoding" → "Job completed"